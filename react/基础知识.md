## 一. 介绍
babel.js的作用：将jsx代码解析成js代码

## 二. 组件
### 1. 组件定义
#### （1）工厂函数方法（简单组件，没有state的组件可以用函数方法创建）
```javascript
// 定义组件
function MyComponent() {
  return <h1>工厂函数方法定义组件（简单组件）</h1>
}
// 渲染组件标签
ReactDOM.render(<MyComponent />, document.getElementById('container'))
```
#### （2）ES6 类方法（复杂组件，组件有state）
```javascript
// 定义组件
class MyComponent2 extends React.Component {
  // 组件渲染时会调用render方法
  render() {
    return <h1>ES6类方法定义组件（复杂组件）</h1>
  }
}
// 渲染组件标签
ReactDOM.render(<MyComponent2 />, document.getElementById('container'))
```

### 2. 组件的三大属性
#### （1）state
state是组件对象最重要的属性，state的值是一个对象，平时对state的操作包括：初始化state、获取state值、更新state值
```javascript
class Like extends React.Component {
  // state初始化在constructor里面
  // constructor(props) {
  //   // super调用父类型的构造函数
  //   super(props)
  //   // 初始化state
  //   this.state = {
  //     isLikeMe: false
  //   }
  //   // 将新增方法中的this指向组件对象！！！
  //   // 可以不使用bind，直接在定义方法的时候使用箭头函数即可
  //   // this.handleClick = this.handleClick.bind(this)
  // }

  // 定义state的简写方法，也可以不写在constructor中，直接写在外面
  state = {
    isLikeMe: false
  };

  render() {
    // 获取state值
    const { isLikeMe } = this.state
    return <h2 onClick={ this.handleClick }>{ isLikeMe ? 'yes' : 'no' }</h2>
  }
  // 更新state值
  handleClick = () => {
    // 注意：对于新添加的方法，方法里面的this指向的不是组件对象，而是undefined！！！此时需要修改这些方法的this指向
    const reverseValue = !this.state.isLikeMe
    // 使用setState方法更新state值
    this.setState({
      isLikeMe: reverseValue
    })
  }
}

ReactDOM.render(<Like />, document.getElementById('container'))
```
#### （2）props
子组件用props接收父组件传过来的参数
```javascript
// 函数方法定义组件
function Person(props) {
  return (
    <ul>
      <li>姓名：{props.name}</li>
      <li>性别：{props.sex}</li>
      <li>年龄：{props.age}</li>
    </ul>
  )
}

// 限制组件属性值的类型和是否必需，这里需要npm install prop-types，然后再import
import PropTypes from 'prop-types'

// 类方法定义组件
class Person extends React.Component {
  // static的作用是给  组件类  设置props类型限制，如果不写static，会给组件对象设置props
  static propTypes = {
    name: PropTypes.string.isRequired,   // 加上isRequired以后，即使父组件没传递值也会抛出警告
    age: PropTypes.number // 年龄是数值类型
  };
  render() {
    return (
      <ul>
        <li>姓名：{this.props.name}</li>
        <li>性别：{this.props.sex}</li>
        <li>年龄：{this.props.age}</li>
      </ul>
    )
  }
}

// 指定属性默认值
Person.defaultProps = {
  sex: '男',
  age: 18
}


// 可以写到组件类中去
// Person.propTypes = {
//     name: PropTypes.string.isRequired,   // 加上isRequired以后，即使父组件没传递值也会抛出警告
//     age: PropTypes.number // 年龄是数值类型
// }

// 渲染组件标签
const p1 =  {
  name: '张三',
  sex: '男',
  age: 18
}
ReactDOM.render(<Person name={p1.name} sex={p1.sex} age={p1.age} />, document.getElementById('container'))
// 简便写法
/**
 * ...的作用
 * 1.打包
 * function fn(...as) {}  fn(1, 2, 3)
 * 2.解包
 * const arr1 = [1, 2, 3] const arr2 = [6, ...arr1, 9]
*/
ReactDOM.render(<Person {...p1} />, document.getElementById('container'))
```
#### （3）refs与事件处理
```javascript
class Like extends React.Component {
  // state初始化在constructor里面
  constructor(props) {
    // super调用父类型的构造函数
    super(props)
    // 初始化state
    this.state = {
      isLikeMe: false
    }
    // 将新增方法中的this指向组件对象！！！
    this.handleClick = this.handleClick.bind(this)
  }
  render() {
    // 获取state值
    const { isLikeMe } = this.state
    // ref这里是一个回调函数，参数就是ref所在的DOM，这里将ref所在的DOM赋值给了组件对象，组件对象里面就可以直接取到这个DOM
    return <h2 onClick={ this.handleClick } ref={h2 => this.h2 = h2}>{ isLikeMe ? 'yes' : 'no' }</h2>
  }
  // 更新state值
  handleClick() {
    // 注意：对于新添加的方法，方法里面的this指向的不是组件对象，而是undefined！！！此时需要修改这些方法的this指向
    const reverseValue = !this.state.isLikeMe
    // 使用setState方法更新state值
    this.setState({
      isLikeMe: reverseValue
    })
    // 直接通过this.h2就可以访问到ref绑定的DOM
    const h2DOM = this.h2
  }
}

ReactDOM.render(<Like />, document.getElementById('container'))
```

**接下来看一个todolist的例子**
```javascript
import PropTypes from "prop-types";
import React from "react";

class App extends React.Component {
  // constructor(props) {
  //   super(props);
  //   this.state = {
  //     todos: [
  //       { key: 0, value: "吃饭" },
  //       { key: 1, value: "睡觉" },
  //       { key: 2, value: "打豆豆" },
  //     ],
  //   };
  //   // 修改this指向
  //   // 可以不使用bind，直接在定义方法的时候使用箭头函数即可
  //   // this.addTodo = this.addTodo.bind(this);
  // }
  // 定义state的简写方法，不写在constructor中，直接写在外面
  state = {
    todos: [
      { key: 0, value: "吃饭" },
      { key: 1, value: "睡觉" },
      { key: 2, value: "打豆豆" },
    ],
  };
  render() {
    const { todos } = this.state;
    return (
      <div>
        <h1>Simple TODO List</h1>
        <Add count={todos.length} addTodo={this.addTodo} />
        <List todos={todos} />
      </div>
    );
  }

  addTodo = (todo) => {
    // this.state.todos.unshift(todo) // 修改组件状态不能这么写，要用setState
    const { todos } = this.state;
    todos.unshift(todo);
    this.setState({ todos });
  };
}

class Add extends React.Component {
  // static的作用是给  组件类  设置props类型限制，如果不写static，会给组件对象设置props
  static propTypes = {
    count: PropTypes.number.isRequired,
    addTodo: PropTypes.func.isRequired,
  };

  render() {
    const { count } = this.props;
    return (
      <div>
        <input type="text" ref={(input) => (this.todoInput = input)} />
        <button onClick={this.add}>add {count + 1}</button>
      </div>
    );
  }

  add = () => {
    const todo = this.todoInput.value.trim();
    if (!todo) return;
    const { count, addTodo } = this.props;
    addTodo({ key: count, value: todo });
    this.todoInput.value = "";
  };
}
// 设置props类型限制
// 可以写到组件类中去
// Add.propTypes = {
//   count: PropTypes.number.isRequired,
//   addTodo: PropTypes.func.isRequired,
// };

class List extends React.Component {
  render() {
    const { todos } = this.props;
    return (
      <div>
        <ul>
          {todos.map((item) => (
            <li key={item.key}>{item.value}</li>
          ))}
        </ul>
      </div>
    );
  }
}
// 设置props类型限制
List.propTypes = {
  todos: PropTypes.array.isRequired,
};

export default App;

```

### 3. 组件的生命周期
#### （1）组件的三个生命周期状态
- Mount: 插入真实DOM
- Update: 被重新渲染
- Unmount: 被移出真实DOM
#### （2）React为每个状态都提供了钩子函数
- componentWillMount()
- componentDidMount()
- componentWillUpdate()
- componentDidUpdate()
- componentWillUnmount()
#### （3）生命周期流程
##### ① 第一次初始化渲染显示（**只执行一次**）: ReactDOM.render()
- constructor(): 创建对象初始化state
- componentWillMount(): 将要挂载前回调
- render(): 插入虚拟DOM回调
- componentDidMount(): 挂载完毕回调
##### ② 每次更新state（**执行n次**）: this.setState()
- componentWillUpdate(): 将要更新回调
- render(): 更新（重新渲染）
- componentDidUpdate(): 已经更新回调
##### ③ 移除组件（**只执行一次**）: ReactDOM.unmountComponentAtNode(containerDOM)
- componentWillUnmount(): 组件将要被移除回调
#### （4）父子组件生命周期
componentWillReceiveProps(newProps): 当组件接收到新的props时调用（**此方法已过时，不建议使用**）

### 4. 如何给组件绑定样式
在style中使用两个大括号绑定样式，最外层大括号表示style中要写js代码，内层大括号表示样式是键值对，需要对象包裹
```javascript
render() {
  const { opacity } = this.state
  return(
    <div>
      <h2 style={{opacity: opacity}}>xxx</h2>
    </div>
  )
}
```

### 5. 组件间通信方式
#### （1）通过props传递
- 共同的数据放在父组件上，特有的数据放在自己组件内部
- 通过props可以传递一般数据和函数数据，只能一层一层传递
- 一般数据：父组件传递数据给子组件 ---> 子组件读取数据
- 函数数据：父组件传递函数给子组件 ---> 子组件调用函数，**同时可以通过函数传参的方式给父组件传递数据**

#### （2）使用消息订阅(subscribe)-发布(publish)机制
- 工具库：PubSubJS
- 下载：npm install pubsub-js -S
- 使用：
```javascript
// 引入
import PubSub from 'pubsub-js'
// 发布（触发）
PubSub.publish('eventName', 'params')
// 订阅
PubSub.subscribe('eventName', funcName)
// 订阅的回调函数funcName接收两个参数，第一个参数为消息名（eventName），第二个参数是触发消息时传递的数据
```

### 6. 包装第三方组件
很多时候，我们在使用一些第三方组件时，需要把第三方组件拿过来二次封装，如何保证二次封装好的组件可以具备第三方组件的全部属性呢，如果一个一个的在props里面声明就太死板了，使用{...this.props}即可灵活实现。
```javascript
import React, {Component} from 'react'
// 第三方路由组件
import {NavLink} from 'react-router-dom'

export default class MyNavLink extends Component {
  render() {
    // 将外部传入所有属性传递给NavLink
    return <NavLink {...this.props} activeClassName="activeClass" />
  }
}
```

## 三. React路由
### 1. 相关API
#### （1）组件
```html
<BrowserRouter></BrowserRouter>
<HashRouter></HashRouter>
<Route></Route>
<Redirect></Redirect>
<Link></Link>
<NavLink></NavLink>
<Switch></Switch>
```
### 2. 基本路由使用
#### （1）入口
要使用react-router，需要将应用包裹在路由组件中
```javascript
import ReactDOM from 'react-dom'
import {BrowserRouter, HashRouter} from 'react-router-dom'
ReactDOM.render(
  (
    <BrowserRouter>
      <App>
    </BrowserRouter>
  ),
  document.getElementById('root')
)
```

### 3. 嵌套路由

### 4. 路由传参
和vue类似
#### （1）params方式
```
// 路由页面：
<Route path='/home/message/:id' component={Demo}></Route>  //注意要配置 /:id
// 路由跳转并传递参数：

// 链接方式：
<Link to={'/home/message/'+'6'}>XX</Link>                  // 或：<Link to={{pathname:'/home/message/'+'6'}}>XX</Link>

// js方式：
this.props.history.push('/home/message/'+'6')              // 或：this.props.history.push({pathname:'/home/message/'+'6'})

// 然后在跳转过去的组件里面通过props.match获取
const {id} = this.props.match.params
```
#### （2）query方式
```
// 路由页面：
<Route path='/home/message' component={Demo}></Route>  //无需配置
// 路由跳转并传递参数：

// 链接方式：
<Link to={{pathname:'/home/message',query:{id:22}}}>XX</Link>

// js方式：
this.props.history.push({pathname:'/home/message',query:{id:22}})

// 然后在跳转过去的组件里面通过props.location获取
const {id} = this.props.location.query
```

### 5. 路由的跳转方式
#### （1）通过组件标签跳转
```html
<NavLink to="path" />
```
#### （2）通过js代码跳转
```javascript
this.props.history.push
```

## 四. Redux
### 1. 简介
- Redux是一个独立专门用于做状态管理的JS库（不是react插件库）
- 它可以用在react、angular、vue等项目中，但基本与react配合使用
- 作用：管理react应用中多个组件共享的状态

### 2. 核心api
#### 2.1 createStore()
创建包含指定reducer的store对象
```javascript
import { createStore } from 'redux'
import reducers from './redux/reducers'
const store = createStore(reducers) // createStore方法需要传一个reducer进来
```

#### 2.2 store对象
##### （1）介绍
- redux库最核心的管理对象
- 它内部维护着：state、reducer
##### （2）核心方法
- getState()
- dispatch(action)
- subscribe(listener)

```javascript
store.getState()
store.dispatch({ type: 'INCREMENT', number })
store.subscribe(render)
```

#### 2.3 applyMiddleware()
基于redux的中间件
```javascript
import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk' // redux异步中间件

const store = createStore(
  counter,
  applyMiddleware(thunk) // 应用上异步中间件
)
```

#### 2.4 combineReducers()
合并多个reducer函数
```javascript
export default combineReducers({
  users,
  chartUser,
  chart
})
```

### 3. redux的三个核心概念
#### 3.1 action
- 标识要执行行为的对象
- 包含两个方面的属性
    - type：标识属性，值为字符串，唯一，必要属性
    - xxx：数据属性，值类型任意，可选属性
- action creater（创建action的函数）

#### 3.2 reducer（修改store的方法）
- 根据老的state和action，产生新的state的纯函数
- 注意
    - 返回一个新的状态
    - 不要修改原来的状态

#### 3.3 store
将state，action和reducer联系在一起的对象

## 五. react-redux（简化在react中使用redux的react库）
### 1. 介绍
react-redux将所有组件分成两大类
#### （1）UI组件
- 只负责UI的呈现，不带有任何业务逻辑
- 通过props接收数据
- **不使用任何redux的api**
- 一般保存在components文件夹下
#### （2）容器组件
- 负责管理数据和业务逻辑，不负责UI的呈现
- **使用redux的api**
- 一般保存在containers文件夹下

### 2. 相关API
#### （1）Provider
让所有组件都可以得到state数据
```
<Provider store={store}>
  <App />
</Provider>
```
#### （2）connect
用于包装UI组件，生成容器组件
```
import { connect } from 'react-redux'

connect(mapStateToProps, mapDispatchToProps)(Counter)
```

## 一. 介绍
babel.js的作用：将jsx代码解析成js代码

## 二. 组件
### 1. 组件定义
#### （1）工厂函数方法（简单组件，没有state的组件可以用函数方法创建）
```javascript
// 定义组件
function MyComponent() {
  return <h1>工厂函数方法定义组件（简单组件）</h1>
}
// 渲染组件标签
ReactDOM.render(<MyComponent />, document.getElementById('container'))
```
#### （2）ES6 类方法（复杂组件，组件有state）
```javascript
// 定义组件
class MyComponent2 extends React.Component {
  // 组件渲染时会调用render方法
  render() {
    return <h1>ES6类方法定义组件（复杂组件）</h1>
  }
}
// 渲染组件标签
ReactDOM.render(<MyComponent2 />, document.getElementById('container'))
```

### 2. 组件的三大属性
#### （1）state
state是组件对象最重要的属性，state的值是一个对象，平时对state的操作包括：初始化state、获取state值、更新state值
```javascript
class Like extends React.Component {
  // state初始化在constructor里面
  constructor(props) {
    // super调用父类型的构造函数
    super(props)
    // 初始化state
    this.state = {
      isLikeMe: false
    }
    // 将新增方法中的this指向组件对象！！！
    this.handleClick = this.handleClick.bind(this)
  }
  render() {
    // 获取state值
    const { isLikeMe } = this.state
    return <h2 onClick={ this.handleClick }>{ isLikeMe ? 'yes' : 'no' }</h2>
  }
  // 更新state值
  handleClick() {
    // 注意：对于新添加的方法，方法里面的this指向的不是组件对象，而是undefined！！！此时需要修改这些方法的this指向
    const reverseValue = !this.state.isLikeMe
    // 使用setState方法更新state值
    this.setState({
      isLikeMe: reverseValue
    })
  }
}

ReactDOM.render(<Like />, document.getElementById('container'))
```
#### （2）props
子组件用props接收父组件传过来的参数
```javascript
// 函数方法定义组件
function Person(props) {
  return (
    <ul>
      <li>姓名：{props.name}</li>
      <li>性别：{props.sex}</li>
      <li>年龄：{props.age}</li>
    </ul>
  )
}

// 类方法定义组件
class Person extends React.Component {
  render() {
    return (
      <ul>
        <li>姓名：{this.props.name}</li>
        <li>性别：{this.props.sex}</li>
        <li>年龄：{this.props.age}</li>
      </ul>
    )
  }
}

// 指定属性默认值
Person.defaultProps = {
  sex: '男',
  age: 18
}

// 限制组件属性值的类型和是否必需，这里需要npm install prop-types，然后再import
import PropTypes from 'prop-types'
Person.propTypes = {
    name: PropTypes.string.isRequired,   // 加上isRequired以后，即使父组件没传递值也会抛出警告
    age: PropTypes.number // 年龄是数值类型
}

// 渲染组件标签
const p1 =  {
  name: '张三',
  sex: '男',
  age: 18
}
ReactDOM.render(<Person name={p1.name} sex={p1.sex} age={p1.age} />, document.getElementById('container'))
// 简便写法
/**
 * ...的作用
 * 1.打包
 * function fn(...as) {}  fn(1, 2, 3)
 * 2.解包
 * const arr1 = [1, 2, 3] const arr2 = [6, ...arr1, 9]
*/
ReactDOM.render(<Person {...p1} />, document.getElementById('container'))
```
#### （3）refs与事件处理
```javascript
class Like extends React.Component {
  // state初始化在constructor里面
  constructor(props) {
    // super调用父类型的构造函数
    super(props)
    // 初始化state
    this.state = {
      isLikeMe: false
    }
    // 将新增方法中的this指向组件对象！！！
    this.handleClick = this.handleClick.bind(this)
  }
  render() {
    // 获取state值
    const { isLikeMe } = this.state
    // ref这里是一个回调函数，参数就是ref所在的DOM，这里将ref所在的DOM赋值给了组件对象，组件对象里面就可以直接取到这个DOM
    return <h2 onClick={ this.handleClick } ref={h2 => this.h2 = h2}>{ isLikeMe ? 'yes' : 'no' }</h2>
  }
  // 更新state值
  handleClick() {
    // 注意：对于新添加的方法，方法里面的this指向的不是组件对象，而是undefined！！！此时需要修改这些方法的this指向
    const reverseValue = !this.state.isLikeMe
    // 使用setState方法更新state值
    this.setState({
      isLikeMe: reverseValue
    })
    // 直接通过this.h2就可以访问到ref绑定的DOM
    const h2DOM = this.h2
  }
}

ReactDOM.render(<Like />, document.getElementById('container'))
```

## 一. axios特点
- 基于(XMLHttpRequest)xhr + promise 的异步ajax请求库
- 浏览器端、node端都可以使用
- 支持请求/响应拦截器，支持请求取消
- 请求/响应数据转换
- 批量发送多个请求

## 二. axios用法
- axios(config)                         通用/最本质的发任意类型请求的方式（**此时axios是一个方法**）
- axios(url[,config])                   可以只指定url发get请求
- axios.request(config)                 等同于axios(config)
- axios.get(url[,config])               发get请求（**此时axios是一个对象，调用了get方法**）
- axios.delete(url[,config])            发delete请求
- axios.post(url[,data, config])        发post请求
- axios.put(url[,data, config])         发put请求
- axios.default.xxx                     请求的默认全局配置(method/baseURL/params/timeout...)
- axios.interceptors.request.use()      添加请求拦截器
- axios.interceptors.response.use()     添加响应拦截器
- axios.create(config)                  创建一个新的axios（**他没有下面的功能**）
- axios.Cancel()                        用于创建取消请求的错误对象
- axios.CancelToken()                   用于创建取消请求的token对象
- axios.isCancel()                      是否是一个取消请求的错误
- axios.all(promise)                    用于批量执行多个异步请求

## 三. 问题
### 1. 为什么使用axios(config)可以发起请求，使用axios.get也可以发起请求，axios内部源码是怎样处理的？
因为源码中有这样一段
```javascript
var instance = bind(Axios.prototype.request, context); // 等同于 var instance = Axios.prototype.request.bind(context)
```
使用了bind方法将instance指向了request方法，所以我们使用axios(config)可以发起请求，本质上还是调用了axios.request方法

```javascript
// Copy axios.prototype to instance
utils.extend(instance, Axios.prototype, context);
```
上面的源码使用extend方法扩展了instance方法，将Axios.prototype下的**方法**都扩展到了instance下，所以我们可以通过axios（即instance）.get方法发起ajax请求，**并且调用axios.get（post，put等同理）其实本质上还是调用了axios.request方法**

```javascript
// Copy context to instance
utils.extend(instance, context);
```
上面的源码将Axios类实例化的对象context的**属性**添加到instance里面

### 2. axios请求拦截器为什么可以做到在请求前调用，响应拦截器为什么可以做到在获取请求结果后调用，源码的设计思路是怎样的（即拦截器的实现原理）
```javascript
// Hook up interceptors middleware
// 创建拦截器中间件，dispatchRequest[用来发送请求]，undefined[用来补位]
var chain = [dispatchRequest, undefined];
var promise = Promise.resolve(config);

this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
